
## TCP/UDP 


**1.TCP和UDP区别**

	A: 1. TCP:
		TCP面向连接（如打电话要先拨号建立连接）
		对系统资源的要求 TCP较多
		每一条TCP连接只能是点到点的
		TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流
		(TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除)
		TCP保证数据正确性, 数据顺序
	
	   2. UDP:
	        是无连接的，即发送数据之前不需要建立连接
	        对系统资源的要求 UDP少
	        UDP程序结构较简单
	        UDP支持一对一，一对多，多对一和多对多的交互通信
	        UDP是面向报文的
		(应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文。)
	        UDP可能丢包，UDP不保证数据正确性, 数据顺序

**2.TCP和UDP的使用场景**

	A: 1. TCP: Web
		   SSH, FTP, telnet
			   	
	   2. UDP: 看视频，直播（丢帧可以）
	           游戏(Lag)

**3.tcp首部结构**

	A: * 源端口 source port
	   * 目的端口 destination port
	   * 序号 sequence number
	   * 确认号 acknowledgment number 
	   * 窗口大小 window size
	   * 检验和 checksum

**4.发送3个80字节包，TCP与UDP下对端分别接受几次(其实就是TCP与UDP区别之一，TCP基于流)**

	A: TCP: 1次
	   UDP: 3次

**5.计算机网络TCP的可靠性保证**
	
	A: 滑动窗口了、拥塞控制、慢开始、拥塞避免、快重传、快恢复、三次握手、四次挥手

**6.TCP三次握手的过程，建立完成后双方处于什么状态?**

	A:
	
<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/100327002629.png" width="60%">

	建立完成后双方处于Established状态 客户端和服务器就建立了tcp连接。这时可以调用accept函数获得此连接

**7.怎么断开连接?**

	A: （1）第一次挥手     因此当主动方发送断开连接的请求（即FIN报文）给被动方时，
	        仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。    
	   （2）第二次挥手     被动方此时有可能还有相应的数据报文需要发送，
	        因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。
		这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。   
	   （3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。
	        发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。   
	   （4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。

<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/100327022731.jpg" width="60%">

**8.为什么需要“三次握手?**

	A: "已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，
	而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。
	但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。
	假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，
	也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。
	采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，
	就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。


**8.time wait状态是哪一方的，有什么作用，时间持续多久?**

	A: 通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。

	   客户端主动关闭连接时，会发送最后一个ack后，然后会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态。
	   
<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/734c7efd-3d62-3946-a234-acdddff3b507.jpg" width="60%">

**9.为什么要有time_wait，如果没有的话什么危害?**

	A: 可靠地实现TCP全双工连接的终止：（即在TIME_WAIT下等待2MSL，是为了尽最大努力保证四次握手正常关闭)
	   防止上一次连接中的包，迷路后重新出现，影响新连接
          （经过2MSL，上一次连接中所有的重复包都会消失），
	   
	   如果没有的话:
	   在进行关闭连接四路握手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，
	   服务器将重发最终的FIN，因此客户端必须维护状态信息允 许它重发最终的ACK。
           如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误。
           因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，
	   主动关闭 的客户端必须维持状态信息进入TIME_WAIT状态。


**10.time_wait时间大概是多少?**

	A: 具体时间是4-6分钟，也就是2个报文(segment)最长生存时间。

**11.Tcp粘包**

	A: 接收端只收到一个数据包，这一个数据包中包含了发送端发送的两个数据包合起來的信息，这种现象即为粘包。
	
	   * 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
	   * 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
	   * 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
	   * 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。


**12.滑动窗口协议的概念。**

	A: TCP滑动窗口分为接受窗口，发送窗口
	   滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，
	   从而达到防止发送方发送速度过快而导致自己被淹没的目的。

	   实际窗口的大小取决于发送窗口和拥塞窗口这两者的较小值。
	   假设窗口从左往右滑。窗口外的左侧是已被接收方确认（根据ACK的序号）的数据，右侧是由于窗口大小制限还未发送的数据


**13，阻塞控制中，阻塞窗口大小怎么动态变化的?**

	A: 1.慢启动
		当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，
		每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长
		发送方取min(拥塞窗口,接收窗口(rwnd))作为发送的上限

	   2.一个是快重传
		首先对于接收方来说，如果接收方收到一个失序的报文段，
		就立即回送一个 ACK 给发送方，而不是等待发送延时的 ACK。
		所谓失序的报文是指，用户没有按照顺序收到 TCP 报文段，
		比如接收方收到了报文 M1, M2, M4，那么 M4 就称为失序 报文。

		这样做的目的是可以让发送方尽可能早的知道报文段 M3 未到达接收方。快重传算法规定
		如果发送方一连收到 3 个重复的确认，就应当立即传送对方未收到的报文 M3，而不必等待 M3 的重传计时器到期。
		
           
	   3. 快恢复算法:
	       一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），
	       (如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。)
	       TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh, 重新进入拥塞避免阶段。

	       
	
<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/20170415161738770.png" width="60%">



**14. 拥塞避免**

	A: 从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，
	   但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，
	   当cwnd超过该值后，慢启动过程结束 
	
	   1.把ssthresh降低为cwnd值的一半

	   2.把cwnd重新设置为1

           3.重新进入慢启动过程。


**15.TCP洪水攻击**

	A: 利用TCP协议缺陷，发送大量伪造的TCP连接请求，请求连接的第一个握手包（SYN包），
	   被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。
	   导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，
	   塞满TCP等待连接队列，资源耗尽，让正常的业务请求连接不进来。


## HTTP/HTTPS


**1.网络字节序，如何判断机器大小端模式，自己实现主机跟网络字节的转换的函数**

	A: 1.为什么会出现大小端模式？
	不同的cpu采用的大小端模式不一致。X86是小端模式。
	而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

	2.大小端模式的不同带来的问题是什么？如何解决？
	如果存在数据网络传输，如果大小端模式不一致，如果不经过转换，必然会导致数据不致，出现错误。
	解决方法：统一将网络上传输的字节序采用同一种模式，这样收发数据时，
	就会根据主机对应的模式是否和网络字节对应的模式一致，来判断是否需要进行转换。
	这样即使不同的设备使用不同的模式，网络传输不会出现问题。

**15.网络七层协议**

**描述一个http从发送请求到接收消息整个七层过程，用到的协议**


**19. HTTP 协议** 

	A: HTTP协议是Hyper Text Transfer Protocol的缩写,是用于从万维网（WWW:World Wide Web ）
	   服务器传输超文本(Hyper Text)到本地浏览器的传送协议。
	   HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。
	   Web服务器根据接收到的请求后，向客户端发送响应信息。

	   主要特点
	   1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
	   请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。
	   由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

	   2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

	   3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，
	   并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

	   4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。
	   缺少状态意味着如果后续处理需要前面的信息，则它必须重传，
	   这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

**5.http1.0和1.1有什么区别**

	A: http 1.0 您必须为每个请求/响应对打开一个新连接。 在每个响应之后，连接将被关闭。
	   http 1.1 必需有host header,允许您拥有持久连接，这意味着您可以在同一个HTTP连接上拥有多个请求/响应。
	   http 2.0 允许将请求和响应拆分成块，并以混合方式返回，从而避免堵塞。

**6.https 端到端中间的过程。**


**20. HTTPS 如何加密**

	A: HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。
	服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。


**SSL的位置**

	A: SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，
	而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。


**21. HTTPS 加密算法 SSL。**

	A: 1、对称加密

	有流式、分组两种，加密和解密使用相同密钥的加密算法。
	对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。
	假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要2个密钥并交换使用，
	如果企业内用户有n个，则整个企业共需要n×(n-1) 个密钥，密钥的生成和分发将成为企业信息部门的恶梦。

	例如：DES、AES-GCM、ChaCha20-Poly1305等

	2、非对称加密

	加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，
	私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。
	
	指加密和解密使用不同密钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，
	双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。如果企业中有n个用户，
	企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，
	因此加密密钥的分发将变得十分简单。同时，由于每个用户的私钥是唯一的，
	其他用户除了可以可以通过信息发送者的公钥来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。
	非对称加密的缺点是加解密速度要远远慢于对称加密，在某些极端情况下，甚至能比非对称加密慢上1000倍。

	例如：RSA、DSA、ECDSA、 DH、ECDHE

	3、哈希算法

	将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。

	例如：MD5、SHA-1、SHA-2、SHA-256 等

	4、数字签名

	签名就是在信息的后面再加上一段内容（信息经过hash后的值），
	可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。
    
**21. HTTP GET POST区别。**

	A: 最直观的就是语义上的区别，get用于获取数据，post用于提交数据。
	   1.GET是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。 
	   2. 实际上HTTP协议对URL长度是没有限制的；限制URL长度大多数是浏览器或者服务器的配置参数POST1.
	      同样的，HTTP协议没有对POST进行任何限制，一般是受服务器配置限制或者内存大小
	   3. GET是通过URL方式请求，可以直接看到，明文传输。
	   4.POST是通过请求header请求，可以开发者工具或者抓包可以看到，同样也是明文的。
	   5.GET请求会保存在浏览器历史纪录中，还可能会保存在Web的日志中。

**22. HTTP请求会保持连接吗？**

	A: HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）
	是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。
	
	注: web服务器会保持连接若干秒(Apache中默认15秒)

**21. 服务器如何解决大量的用户访问。**
	我说线程池。说到等待队列。他说等待队列的大小值如何给定。 服务器如何确定访问的最大 客户端 数目。


**8.Cookies和session的关系**

	A: 1，session 在服务器端，cookie 在客户端（浏览器）
	   2，session 默认被存在在服务器的一个文件里（不是内存）
	   3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，
	      也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其 它方式实现，比如在 url 中传递 session_id）
	   4，session 可以放在 文件、数据库、或内存中都可以。
	   5，用户验证这种场合一般会用 session 

	   因此，维持一个会话的核心就是客户端的唯一标识，即 session id
   
**9.Cookies的最大保存时间**

	A: 你可以设置任意保存时间, 1分钟, 1年, 10年,100年都行. 但不可能是永久的
