
## TCP/UDP 


**1.TCP和UDP区别**

	A: 1. TCP:
		TCP面向连接（如打电话要先拨号建立连接）
		对系统资源的要求 TCP较多
		每一条TCP连接只能是点到点的
		TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流
		(TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除)
		TCP保证数据正确性, 数据顺序
	
	   2. UDP:
	        是无连接的，即发送数据之前不需要建立连接
	        对系统资源的要求 UDP少
	        UDP程序结构较简单
	        UDP支持一对一，一对多，多对一和多对多的交互通信
	        UDP是面向报文的
		(应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文。)
	        UDP可能丢包，UDP不保证数据正确性, 数据顺序

**2.TCP和UDP的使用场景**

	A: 1. TCP: Web
		   SSH, FTP, telnet
			   	
	   2. UDP: 看视频，直播（丢帧可以）
	           游戏(Lag)

**3.tcp首部结构**

	A: * 源端口 source port
	   * 目的端口 destination port
	   * 序号 sequence number
	   * 确认号 acknowledgment number 
	   * 窗口大小 window size
	   * 检验和 checksum

**4.发送3个80字节包，TCP与UDP下对端分别接受几次(其实就是TCP与UDP区别之一，TCP基于流)**

	A: TCP: 1次
	   UDP: 3次

**5.计算机网络TCP的可靠性保证**
	
	A: 滑动窗口了、拥塞控制、慢开始、拥塞避免、快重传、快恢复、三次握手、四次挥手

**6.TCP三次握手的过程，建立完成后双方处于什么状态?**

	A:
	
<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/100327002629.png" width="60%">

	建立完成后双方处于Established状态 客户端和服务器就建立了tcp连接。这时可以调用accept函数获得此连接

**7.怎么断开连接?**

	A: （1）第一次挥手     因此当主动方发送断开连接的请求（即FIN报文）给被动方时，
	        仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。    
	   （2）第二次挥手     被动方此时有可能还有相应的数据报文需要发送，
	        因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。
		这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。   
	   （3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。
	        发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。   
	   （4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。

<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/100327022731.jpg" width="60%">

**8.为什么需要“三次握手?**

	A: "已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，
	而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。
	但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。
	假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，
	也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。
	采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，
	就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。


**8.time wait状态是哪一方的，有什么作用，时间持续多久?**

	A: 通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。

	   客户端主动关闭连接时，会发送最后一个ack后，然后会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态。
	   
<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/734c7efd-3d62-3946-a234-acdddff3b507.jpg" width="60%">

**9.为什么要有time_wait，如果没有的话什么危害?**

	A: 可靠地实现TCP全双工连接的终止：（即在TIME_WAIT下等待2MSL，是为了尽最大努力保证四次握手正常关闭)
	   防止上一次连接中的包，迷路后重新出现，影响新连接
          （经过2MSL，上一次连接中所有的重复包都会消失），
	   
	   如果没有的话:
	   在进行关闭连接四路握手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，
	   服务器将重发最终的FIN，因此客户端必须维护状态信息允 许它重发最终的ACK。
           如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误。
           因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，
	   主动关闭 的客户端必须维持状态信息进入TIME_WAIT状态。


**10.time_wait时间大概是多少?**

	A: 具体时间是4-6分钟，也就是2个报文(segment)最长生存时间。

**11.Tcp粘包**

	A: 接收端只收到一个数据包，这一个数据包中包含了发送端发送的两个数据包合起來的信息，这种现象即为粘包。
	
	   * 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
	   * 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
	   * 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
	   * 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。


**12.滑动窗口协议的概念。**

	A: TCP滑动窗口分为接受窗口，发送窗口
	   滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，
	   从而达到防止发送方发送速度过快而导致自己被淹没的目的。

	   实际窗口的大小取决于发送窗口和拥塞窗口这两者的较小值。
	   假设窗口从左往右滑。窗口外的左侧是已被接收方确认（根据ACK的序号）的数据，右侧是由于窗口大小制限还未发送的数据


**13，阻塞控制中，阻塞窗口大小怎么动态变化的?**

	A: 1.慢启动
		当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，
		每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长
		发送方取min(拥塞窗口,接收窗口(rwnd))作为发送的上限

	   2.一个是快重传
		首先对于接收方来说，如果接收方收到一个失序的报文段，
		就立即回送一个 ACK 给发送方，而不是等待发送延时的 ACK。
		所谓失序的报文是指，用户没有按照顺序收到 TCP 报文段，
		比如接收方收到了报文 M1, M2, M4，那么 M4 就称为失序 报文。

		这样做的目的是可以让发送方尽可能早的知道报文段 M3 未到达接收方。快重传算法规定
		如果发送方一连收到 3 个重复的确认，就应当立即传送对方未收到的报文 M3，而不必等待 M3 的重传计时器到期。
		
           
	   3. 快恢复算法:
	       一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），
	       (如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。)
	       TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh, 重新进入拥塞避免阶段。

	       
	
<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/20170415161738770.png" width="60%">



**14. 拥塞避免**

	A: 从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，
	   但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，
	   当cwnd超过该值后，慢启动过程结束 
	
	   1.把ssthresh降低为cwnd值的一半

	   2.把cwnd重新设置为1

           3.重新进入慢启动过程。


**15.TCP洪水攻击**

	A: 利用TCP协议缺陷，发送大量伪造的TCP连接请求，请求连接的第一个握手包（SYN包），
	   被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。
	   导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，
	   塞满TCP等待连接队列，资源耗尽，让正常的业务请求连接不进来。




## HTTP/HTTPS


**1.网络字节序，如何判断机器大小端模式，自己实现主机跟网络字节的转换的函数**

	A: 1.为什么会出现大小端模式？
	不同的cpu采用的大小端模式不一致。X86是小端模式。
	而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

	2.大小端模式的不同带来的问题是什么？如何解决？
	如果存在数据网络传输，如果大小端模式不一致，如果不经过转换，必然会导致数据不致，出现错误。
	解决方法：统一将网络上传输的字节序采用同一种模式，这样收发数据时，
	就会根据主机对应的模式是否和网络字节对应的模式一致，来判断是否需要进行转换。
	这样即使不同的设备使用不同的模式，网络传输不会出现问题。

15.网络七层协议，描述一个http从发送请求到接收消息整个七层过程，用到的协议


6.https协议？原理？端到端中间的过程。

7.对称加密和非对称加密？

8.Cookies和session的关系

9.Cookies的最大保存时间

5.http1.0和1.1有什么区别
* http 1.0 您必须为每个请求/响应对打开一个新连接。 在每个响应之后，连接将被关闭。
* http 1.1 必需有host header,允许您拥有持久连接，这意味着您可以在同一个HTTP连接上拥有多个请求/响应。
* http 2.0 允许将请求和响应拆分成块，并以混合方式返回，从而避免堵塞。

19. HTTP 协议讲下， HTTPS 如何加密， HTTPS 加密算法 SSL。HTTP GET POST区别。 HTTP请求会保持连接吗？


21. 服务器如何解决大量的用户访问。我说线程池。说到等待队列。他说等待队列的大小值如何给定。 服务器如何确定访问的最大 客户端 数目。


