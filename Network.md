
## TCP/UDP 


**1.TCP和UDP区别**

	A: 1. TCP:
		TCP面向连接（如打电话要先拨号建立连接）
		对系统资源的要求 TCP较多
		每一条TCP连接只能是点到点的
		TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流
		(TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除)
		TCP保证数据正确性, 数据顺序
	
	   2. UDP:
	        是无连接的，即发送数据之前不需要建立连接
	        对系统资源的要求 UDP少
	        UDP程序结构较简单
	        UDP支持一对一，一对多，多对一和多对多的交互通信
	        UDP是面向报文的
		(应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文。)
	        UDP可能丢包，UDP不保证数据正确性, 数据顺序

**2.TCP和UDP的使用场景**

	A: 1. TCP: Web
		   SSH, FTP, telnet
			   	
	   2. UDP: 看视频，直播（丢帧可以）
	           游戏(Lag)

**3.发送3个80字节包，TCP与UDP下对端分别接受几次(其实就是TCP与UDP区别之一，TCP基于流)**

	A: TCP: 1次
	   UDP: 3次

**4.计算机网络TCP的可靠性保证**
	
	A: 滑动窗口了、拥塞控制、慢开始、拥塞避免、快重传、快恢复、三次握手、四次挥手

**5.TCP三次握手的过程，建立完成后双方处于什么状态?**

	A:
	
<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/100327002629.png" width="60%">

	建立完成后双方处于Established状态 客户端和服务器就建立了tcp连接。这时可以调用accept函数获得此连接

**6.怎么断开连接?**

	A: 1. 某个应用进程首先调用close，该端的tcp发送一个FIN分节，表示数据发送完毕。
	   2. 接收到这个FIN的对端执行被动关闭。这个FIN由tcp确认(ACK)。
	   3. 一段时间后，接受到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的tcp也发送一个FIN分节。
	   4. 执行主动关闭的那一端确认(ACK)这个FIN。

<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/100327022731.jpg" width="60%">


**7.time wait状态是哪一方的，有什么作用，时间持续多久?**

	A: 通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。

	   客户端主动关闭连接时，会发送最后一个ack后，然后会进入TIME_WAIT状态，再停留2个MSL时间，进入CLOSED状态。
	   
<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/734c7efd-3d62-3946-a234-acdddff3b507.jpg" width="60%">

**8.为什么要有time_wait，如果没有的话什么危害?**

	A: 可靠地实现TCP全双工连接的终止：（即在TIME_WAIT下等待2MSL，是为了尽最大努力保证四次握手正常关闭)
	   防止上一次连接中的包，迷路后重新出现，影响新连接
          （经过2MSL，上一次连接中所有的重复包都会消失），
	   
	   如果没有的话:
	   在进行关闭连接四路握手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，
	   服务器将重发最终的FIN，因此客户端必须维护状态信息允 许它重发最终的ACK。
           如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误。
           因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，
	   主动关闭 的客户端必须维持状态信息进入TIME_WAIT状态。


**9.time_wait时间大概是多少?**

	A: 具体时间是4-6分钟，也就是2个报文(segment)最长生存时间。

**10.Tcp粘包**

	A: 接收端只收到一个数据包，这一个数据包中包含了发送端发送的两个数据包合起來的信息，这种现象即为粘包。
	
	   * 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
	   * 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
	   * 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
	   * 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。


**11.滑动窗口协议的概念。**

12.阻塞窗口协议

13，阻塞控制中，阻塞窗口大小怎么动态变化的：具体的分两种情况说就行：一个是慢启动 一个是快重传，大家看下课本，这个要画图文字说不清

14.网络字节序，如何判断机器大小端模式，自己实现主机跟网络字节的转换的函数


15.TCP洪水攻击

利用TCP协议缺陷，发送大量伪造的TCP连接请求，请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，塞满TCP等待连接队列，资源耗尽，让正常的业务请求连接不进来。


16.tcp首部结构
* 源端口 source port
* 目的端口 destination port
* 序号 sequence number
* 确认号 acknowledgment number 
* 窗口大小 window size
* 检验和 checksum



## HTTP/HTTPS

15.网络七层协议，描述一个http从发送请求到接收消息整个七层过程，用到的协议


6.https协议？原理？端到端中间的过程。

7.对称加密和非对称加密？

8.Cookies和session的关系

9.Cookies的最大保存时间

5.http1.0和1.1有什么区别
* http 1.0 您必须为每个请求/响应对打开一个新连接。 在每个响应之后，连接将被关闭。
* http 1.1 必需有host header,允许您拥有持久连接，这意味着您可以在同一个HTTP连接上拥有多个请求/响应。
* http 2.0 允许将请求和响应拆分成块，并以混合方式返回，从而避免堵塞。

19. HTTP 协议讲下， HTTPS 如何加密， HTTPS 加密算法 SSL。HTTP GET POST区别。 HTTP请求会保持连接吗？


21. 服务器如何解决大量的用户访问。我说线程池。说到等待队列。他说等待队列的大小值如何给定。 服务器如何确定访问的最大 客户端 数目。


