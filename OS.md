## 进程/线程

1. 进程线程的区别？

	A: 进程和线程的主要差别在资源管理方式。进程有独立的地址空间，
	
	   一个进程至少有一个线程, 所以线程是被包含在进程之中，是进程中的实际运作单位。线程有自己的堆栈(Stack)和局部变量(local var)，
	   但线程之间没有单独的地址空间.
	   

	   所以一个进程崩溃后，在保护模式下不会对其它进程产生影响
	   
	   一个线程崩溃就等于整个进程崩溃.
	   
	   所以多进程的程序要比多线程的程序安全，但在进程切换时，耗费资源较大，效率要差一些。
	   
	   但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

		 1. 一个程序至少有一个进程,一个进程至少有一个线程.

		 2. 线程的划分尺度小于进程，使得多线程程序的并发性高。

		 3. 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。


2. 进程间通信方式
	
	A: * 管道（pipe）
	   * 信号（signal）
	   * Socket

3. 管道一般用途，如何用管道实现非亲缘进程间通信?

     A: 管道的实质：

        管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据

        管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。

        有名管道(FIFO): 
        匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。

        有名管道它提供了一个路径名來关联，以有名管道的文件形式存在于文件系统中，
        
        这样，即使与有名管道的创建进程不存在亲缘关系的进程，

        只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。

        值的注意的是，有名管道严格遵循先进先出FIFO, 对匿名管道及有名管道的读总是从开始处返回数据

        对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。


3. 守护进程和僵尸进程，孤儿进程有什么了解？为什么产生和怎么解决？

     1. 一般情况下，子进程是由父进程创建，而子进程和父进程的退出是无顺序的，两者之间都不知道谁先退出。
        正常情况下父进程先结束会调用 wait 或者 waitpid 函数等待子进程完成再退出，而一旦父进程不等待直接退出，
        则剩下的子进程会被init(pid=1)进程接 收，成会孤儿进程。（进程树中除了init都会有父进程）。

     2. 如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息，则子进程残留的状态信息会变成僵尸进程。

     3. 守护进程（ daemon) 是指在后台运行，没有控制终端与之相连的进程。它独立于控制终端，通常周期性地执行某种任务 。 
       守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断 。

     危害：

     孤儿进程结束后会被 init 进程善后，并没有危害，而僵尸进程则会一直占着进程号，操作系统的进程数量有限则会受影响。

     解决：

     一般僵尸进程的产生都是因为父进程的原因，则可以通过 kill 父进程解决，这时候僵尸进程就变成了孤儿进程，被 init 进程接收

4. 线程里面有什么是独立的？

     线程有自己的堆栈(Stack)和局部变量(local var)

5. 一个进程一定要有一个线程吗？没有线程的进程是什么？

     是的，那个线程叫Main Thread. 一个没有线程的进程可以被看作是单线程的。

6. 协程(Coroutine)是什么？

     子例程(subroutine)的起始处是唯一的入口点，一旦return就完成了子程序的执行，子程序的一个实例只会运行一次。
     但是协程不一样，协程可以使用yield来切换到其他协程，然后再通过resume方法重入（reenter）到上次调用yield的地方，
     并且把resume的参数当成返回值传给了要重入（reenter）的协程。但是coroutine的状态都没有被改变，就像一个可以多次返回的subroutine。

7. 同步和互斥(Mutually Exclusive)是怎么做的？

     a) 同步:
     
     同步，又称直接制约关系，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。

     例如，线程 T2 中的语句 y 要使用线程 T1 中的语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。
          我们可以使用信号量进行同步
          
     b) 互斥:
     
     互斥，又称间接制约关系，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。

     例如，打印机就是一种临界资源，而访问打印机的代码片段称为临界区，故每次只允许一个线程进入临界区。
     —— 我们同样可以使用信号量解决互斥问题，只需把临  界区置于 P(S) 和 V(S) 之间，即可实现两线程对临界资源的互斥访问。
    
     1. 互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
     2. 同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
     3. 同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。
     4. 互斥是一种特殊的同步。


## File System


1. 硬连接和软连接删了，原对象会如何？

     ```shell

     ln file1 file2 
     ln -s file1 file3 

     ```

     * (1) 删除原文件file1，对硬链接file2没影响，对软连接file3有影响(无效)；

     * (2) 删除硬链接file2，对原文件file1，软链接file3没有影响；

     * (3) 删除软链接file3，对原文件file1，硬链接file2都没有影响；

     * (4) 同時删除原文件file1、硬链接file2，文件被真正的删除。


2.硬连接和软连接的底层原理？

     1. 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，
     因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，
     文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 
     
     2. 软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，
     其中包含的有另一文件的位置信息。


3.Inode是什么？

     一、inode

     硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性读取一个"块"（block），每个"块"（block）由八个连续的sector组成。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，文件数据都储存在"块"中，那么还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。

     二、inode的内容


     inode包含文件的元信息，具体有以下内容：

       * 文件的字节数

       * 文件拥有者的User ID

       * 文件的Group ID

       * 文件的读、写、执行权限

       * 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。

       * 链接数，即有多少文件名指向这个inode

       * 文件数据block的位置
       

4.强类型和弱类型，静态类型动态类型是什么？
     
     1. 强、弱类型

     强类型strongly typed：一种语言的所有程序都是well behaved （不出现forbidden behavious）。

     弱类型weakly typed： 否则为 weakly typed。如C语言的缓冲区溢出，属于untrapped errors，属于forbidden behavious

     2. 静、动态类型

     静态类型 statically： 在编译时拒绝ill behaved；

     动态乐行 danamiclly： 在运行时拒绝 ill behaved；
       
     3. 静态类型分为：
     显示类型explicitly typed，类型是语言语法的一部分。

     隐式类型implicity typed，类型通过编译时推导

     4、例子

     无类型：汇编

     弱类型、静态类型：C/C++

     弱类型、动态类型检查：PHP/Perl

     强类型、静态类型检查：JAVA/C#

     强类型、动态类型检查：Python, Scheme

     静态显式类型：Java/C

     静态隐式类型：Ocaml/Haskell



