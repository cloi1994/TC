
**1. 一个程序从开始运行到结束的完整过程。** 

	A: 1. 预编译: 生成一个.i文件。

	   2. 编译: 对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码。

	   3. 汇编: 将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言

	   4. 链接: 把Lib文件和.obj文件合起來生成EXE文件

<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/1338355-20180304130814151-249194330.png" width="60%">

**2. linux里ipc有哪些?**
	
	A: 信号(Signal)，信号量(Semaphore)，消息(Message Q)，

	共享内存(shared memory)，文件系统(FS). Socket, 管道(PIPE)

**3. 为啥要cache呢？** 

	A: 内存的读写速度跟不上cpu所以加了个cache。

	   作用是加快CPU访问常见数据的速度，cache做的事情是把内存里面常用的存储数据存在自己这里供CPU读取，

	   因为cache的访问延迟远远小于内存，所以访问这部分存在cache里的数据就会比直接去访问内存快的多，大概快一个量级。
 
**4. 数据写到cache里以后，具体是怎样更新到内存中的?**

	A:　　写入数据时： 
	
	      第一步，CPU将数据写入Cach水
	
	      第二步，将Cache数据传送到Memory中相应的位置 
	
	      读取数据时： 
	
	      第一步，将Memory中的数据传送到Cache中
	
	      第二步，CPU从Cache中读取数据
	  
**5. Cache的写操作有透写（Write-Through）和回写（Write-Back）两种方式**

	A: 1. 在透写式Cache中，CPU的数据总是写入到内存中，如果对应内存位置的数据在Cache中有一个备份，
	那么这个备份也要更新，保证内存和Cache中的数据永远同步。
	
	   2. 在回写式Cache中，把要写的数据只写到Cache中，并对Cache对应的位置做一个标记，
	只在必要的时候才会将数据更新到内存中。

	   3. 透写方式存在性能瓶颈，性能低于回写方式，现在的CPU设计基本上都是采用Cache回写方式。


**4. 同步与异步?

	A: 同步: 当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行。 
	
	   异步：当一个异步调用发出去后，调用者不能立即得到调用结果的返回。
	   
	   生活中的例子:
	   
           同步买奶茶：小明点单交钱，然后等着拿奶茶
	   
	   异步买奶茶：小明点单交钱，店员给小明一个小票，等小明奶茶做好了，再来取。

**5. 阻塞与非阻塞?

	A: 阻塞调用在发出去后，在消息返回之前，当前进/线程会被挂起，直到有消息返回，当前进/线程才会被激活.

	   非阻塞调用在发出去后，不会阻塞当前进/线程，而会立即返回。

	   生活中的例子:

	   阻塞买奶茶：小明点单交钱，干等着拿奶茶，什么事都不做；

	   非阻塞买奶茶：小明点单交钱，等着拿奶茶，等的过程中，时不时刷刷微博、朋友圈。

**4. Epoll与Select区别以及epoll优点，为什么一般情况下epoll性能比select好，ET模式与LT模式**


**5. Epoll ET下非阻塞读，为什么不能是阻塞**

**6. 多路复用的作用是什么(说了一下nginx和epoll，select,poll之类的)**


**6. linux统计文本中每行第二个字段的和（awk搞定)**

	A: cat a.txt | awk '{ x + $2}'
   
**7. KVM和Docker的区别是什么**

	A: 1. DOCKER采用的是容器虚拟化，kVM是硬件虚拟化，
	
	      Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，	   
	      
	      让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。
	      
	  2. DOCKER充分利用了资源，更能针对PAAS去布署，KVM现在应用在IAAS方面比较多
	     
	     但是KVM是不可能与DOCKER结合，因为它是从零开始，完成整个硬件设备的虚拟化。
	     
	     用户在资源上的随心所欲，但是面向开发环境的复杂性，它不能降低。
   
**7. 操作系统内存分配?**
 
	A: 伙伴系统 - 目的：最大限度的降低内存的碎片化。 
	
           1. 把内存块分成不同的组(1,2,4,8,16,32....)；
	   
           2. 分配内存时找到能够满足条件的最小的块；如果找不到，就找大的块，然后一分为2，分配一块，留一块；
	   
           3. 回收时：如果有相邻的同样大小的块，则合并

**8. 32位64位计算机区别**

	A:  32位最多能使用4G (3G).
	     
	    64位系统最显著的优点，它可以使用超过4GB的内存 (128G).

**9. 32位计算机，程序能分配的最大内存?**

	A: 32位的程序寻址空间是 4G，因此能用的内存有4G，除掉一些系统等使用的东西，3G左右, 可是結果只有2G (1.6). 

**10. 两个1T文件使用4G内存比较相似度**
