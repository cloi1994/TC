
**1. 一个程序从开始运行到结束的完整过程。** 

	A: 1. 预编译: 生成一个.i文件。

	   2. 编译: 对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码。

	   3. 汇编: 将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言

	   4. 链接: 把Lib文件和.obj文件合起來生成EXE文件

<img class="inline" src="https://raw.githubusercontent.com/cloi1994/TC/master/1338355-20180304130814151-249194330.png" width="60%">

**2. linux里ipc有哪些?**
	
	A: 信号(Signal)，信号量(Semaphore)，消息(Message Q)，

	共享内存(shared memory)，文件系统(FS). Socket, 管道(PIPE)

**3. 为啥要cache呢？** 

	A: 内存的读写速度跟不上cpu所以加了个cache。

	   作用是加快CPU访问常见数据的速度，cache做的事情是把内存里面常用的存储数据存在自己这里供CPU读取，

	   因为cache的访问延迟远远小于内存，所以访问这部分存在cache里的数据就会比直接去访问内存快的多，大概快一个量级。
 
**4. 数据写到cache里以后，具体是怎样更新到内存中的?**

	A:　　写入数据时： 
	
	      第一步，CPU将数据写入Cach水
	
	      第二步，将Cache数据传送到Memory中相应的位置 
	
	      读取数据时： 
	
	      第一步，将Memory中的数据传送到Cache中
	
	      第二步，CPU从Cache中读取数据
	  
**5. Cache的写操作有透写（Write-Through）和回写（Write-Back）两种方式**

	A: 1. 在透写式Cache中，CPU的数据总是写入到内存中，如果对应内存位置的数据在Cache中有一个备份，
	那么这个备份也要更新，保证内存和Cache中的数据永远同步。
	
	   2. 在回写式Cache中，把要写的数据只写到Cache中，并对Cache对应的位置做一个标记，
	只在必要的时候才会将数据更新到内存中。

	   3. 透写方式存在性能瓶颈，性能低于回写方式，现在的CPU设计基本上都是采用Cache回写方式。


**6. 同步与异步?**

	A: 同步: 当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行。 
	
	   异步：当一个异步调用发出去后，调用者不能立即得到调用结果的返回。
	   
	   生活中的例子:
	   
	   同步买奶茶：小明点单交钱，然后等着拿奶茶
	   
	   异步买奶茶：小明点单交钱，店员给小明一个小票，等小明奶茶做好了，再来取。

**7. 阻塞与非阻塞?**

	A: 阻塞调用在发出去后，在消息返回之前，当前进/线程会被挂起，直到有消息返回，当前进/线程才会被激活.

	   非阻塞调用在发出去后，不会阻塞当前进/线程，而会立即返回。

	   生活中的例子:

	   阻塞买奶茶：小明点单交钱，干等着拿奶茶，什么事都不做；

	   非阻塞买奶茶：小明点单交钱，等着拿奶茶，等的过程中，时不时刷刷微博、朋友圈。

**8. Epoll与Select区别以及epoll优点，为什么一般情况下epoll性能比select好?**

	A: Select, Poll: 当连接有I/O流事件产生的时候，就会去唤醒进程去处理。 

		   但是进程并不知道是哪个连接产生的I/O流事件，
		   
		   于是进程就挨个不停去问：“请问是你有事要处理吗？” 浪费宝贵的CPU时间片！

	   Epoll: 当连接有I/O流事件产生的时候，epoll就会去告诉进程哪个连接有I/O流事件产生，
	   
	          然后进程就去处理这个进程。如此，多高效！
	   
	   	  Epoll基于事件驱动，epoll_ctl注册事件并注册callback回调函数，
		  
		  Epoll_wait只返回发生的事件避免了像select和poll对事件的整个轮寻操作。

	   Epoll 优点: 可以说是I/O多路复用最新的一个实现，epoll 修复了poll 和select绝大部分问题, 比如：

		       Epoll 现在是线程安全的。 
		       
		       Epoll 现在不仅告诉你socket组里面数据，还会告诉你具体哪个socket(I/O)有数据，你不用自己去找了。
		       
	   Nginx: 异步，非阻塞，IO多路复用

**9. ET模式与LT模式**

	A: LT: 是缺省的工作方式，并且同时支持block和no-block socket；在这种做法中，
	
	       内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，
	   
	       所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。
	   
	   
	   ET: 是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。
	    
	       然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，
	       
	       直到你做了某些操作导致那个文件描述符不再为就绪状态了。
	       
	       但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知。
	       
Level Triggered ( LT )水平触发，默认方式，即当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。

Edge Triggered ( ET )边缘触发，即当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

注：ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

那么对应到socket编程中的accept, read, write，有必要详细说说。

在LT模式下，accept,read,write和平时的编程方式并没有要特别注意的地方，因为只要对应的文件描述符中还有数据未读取或者处于可写状态，都会有通知。例如说，在read的时候没有一次性把缓冲区的数据全部读出来，那么epoll还会再次通知此事件。可以在阻塞和非阻塞的套接字上使用。

然而，在ET模式下，epoll只在事件发生时发生通知，没有新的事件发生就不通知。例如，在read的时候没有一次性把缓冲区的数据全部读出来，那么epoll不会再次通知此事件。除非有新的事件发生，不然监听的描述符是无法被触发。只能在非阻塞的套接字上使用。

Edge Triggered event distribution delivers events only when events happens on the monitored file 。

ET模式下accept存在的问题 考虑这种情况：多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。

解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。

while ((conn_sock = accept(listenfd,(struct sockaddr *) &remote, (size_t *)&addrlen

在一个非阻塞的socket上调用read/write函数, 返回的errno为EAGAIN或者EWOULDBLOCK 
这个错误表示资源暂时不够，read时，读缓冲区没有数据，或者write时，写缓冲区满了。遇到这种情况，如果是阻塞socket，read/write就要阻塞掉。而如果是非阻塞socket，read/write立即返回-1， 同时errno设置为EAGAIN。

**10. Epoll ET下非阻塞读，为什么不能是阻塞**

	A: 如果你的文件描述符如果不是非阻塞的.1.对于读：由于需要一直读直到把数据读完，
	
	   所以大家在编写程序的时候一般会用一个循环一直读取socket，

	   那这个循环势必会在最后一次阻塞，即没有数据可读的情况下，
	   
	   阻塞式socket会在数据读完之后一直阻塞下去，而非阻塞式的socket则返回<0，

	   并让errno 返回 EAGAIN 。2.对于写，当使用阻塞式socket时，socket的unwritable/writable状态变化没有任何意义！！

	   因为此时无论发送多大的数据write总是会阻塞直到所有数据都发送出去。

**11. 多路复用的作用是什么**

	A: 关于I/O多路复用(又被称为“事件驱动”)，首先要理解的是，操作系统为你提供了一个功能，
	   
	   当你的某个socket可读或者可写的时候，它可以给你一个通知。这样当配合非阻塞的socket使用时，
	   
	   只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功。

**12. linux统计文本中每行第二个字段的和（awk搞定)**

	A: cat a.txt | awk '{ x + $2}'
   
**13. KVM和Docker的区别是什么**

	A: 1. DOCKER采用的是容器虚拟化，kVM是硬件虚拟化，
	
	      Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，	   
	      
	      让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。
	      
	  2. DOCKER充分利用了资源，更能针对PAAS去布署，KVM现在应用在IAAS方面比较多
	     
	     但是KVM是不可能与DOCKER结合，因为它是从零开始，完成整个硬件设备的虚拟化。
	     
	     用户在资源上的随心所欲，但是面向开发环境的复杂性，它不能降低。
   
**14. 操作系统内存分配?**
 
	A: 伙伴系统 - 目的：最大限度的降低内存的碎片化。 
	
           1. 把内存块分成不同的组(1,2,4,8,16,32....)；
	   
           2. 分配内存时找到能够满足条件的最小的块；如果找不到，就找大的块，然后一分为2，分配一块，留一块；
	   
           3. 回收时：如果有相邻的同样大小的块，则合并

**15. 32位64位计算机区别**

	A:  32位最多能使用4G (3G).
	     
	    64位系统最显著的优点，它可以使用超过4GB的内存 (128G).

**16. 32位计算机，程序能分配的最大内存?**

	A: 32位的程序寻址空间是 4G，因此能用的内存有4G，除掉一些系统等使用的东西，3G左右, 可是結果只有2G (1.6). 

**17. 两个1T文件使用4G内存比较相似度**
