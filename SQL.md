**1.索引的作用是什么，有什么副作用?**
  
	A: 索引：加速查询的数据结构。
    
       索引的优点:
       第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
       第二，可以大大加快数据的检索速度， 
       第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 
       第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 
       第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
       索引的优点:
       第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
       第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，
            如果要建立聚簇索引，那么需要的空间就会更大
       第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速

**2. Mysql索引底层是怎么存的?**

	A: 底层: B+ Tree:：非叶子节点不存储data，只存储索引key；只有叶子节点才存储data

**2. Mysql索引长度?**

	A: 首先你要知道 mysql的索引都是排好序的。如果区分度高排序越快，区分度越低，排序慢；
	举个例子：  （张，张三，张三哥），如果索引长度取1的话，那么每一行的索引都是 张 
	这个字，完全没有区分度，你让他怎么排序？结果这样三行完全是随机排的，因为索引都一样；
	如果长度取2，那么排序的时候至少前两个是排对了的，如果取3，区分度达到100%，排序完全正确；
	等等，那你说是不是索引越长越好？  答案肯定是错的，比如 (张,李,王)  
	和 （张三啦啦啦，张三呵呵呵，张三呼呼呼）；前者在内存中排序占得空间少，排序也快，
	后者明显更慢更占内存，在大数据应用中这一点点都是很恐怖的；
	所以要做一个取舍；这个取舍不是没有一个固定的量；需要跟你自己的数据库里面的数据来判断；比较常规的公式是：
	test是要加索引的字段，5是索引长度，
	select count(distinct left(test,5))/count(*) from table;   
	求出一个浮点数，这个浮点数是逐渐趋向1的，网上找了个图片来分析下；
	这个地方观察到，当索引长度达到4的时候就已经趋向1了，所以长度设为4是最佳的，
	在大点增加的索引效果已经很小了，这个地方不是说必须接近1才行；
	其实这个值达到0.1就已经可以接受了；总之要找一个平衡点
	
**3.为什么Mysql选择B+TREE索引? B+TREE索引有什么好处?**

	A: 索引本身的Data很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。
	   这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级(太慢)，
	   所以索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，提升索引效率。
	   而B+的特点就是B+树的磁盘读写代价很低和查询效率更加稳定

	   注: 如果把所有同一内部结点的关键字存放在同一盘块中，
		   那么盘块所能容纳的关键字数量也越多。这样，一次性读入内存中的需要查找的关键字也就越多。
		   相对来说IO读写次数也就降低了。

**6. Mysql最左前缀原则**
	
	A: 联合索引
	   最左前缀原则顾名思义，就是最左优先，我们创建了多列索引,相当于创建了(a)单列索引，(a,b)组合索引以及(a,b,c)组合索引。
           注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边
	   1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到
	      遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 
	      如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
	      如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
	   2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，
	      mysql的查询优化器会帮你优化成索引可以识别的形式


**3. 主键和唯一键有什么区别**

	A: (1) 主键索引 PRIMARY KEY
	       它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。
	       当然也可以用 ALTER 命令。记住：一个表只能有一个主键。
	   (2) 唯一索引 UNIQUE
	       唯一索引列的值必须唯一，但允许有空值。如果是组合索引，
	       则列值的组合必须唯一。可以在创建表的时候指定，也可以修改表结构，如：
	       ALTER TABLE table_name ADD UNIQUE (column)
	   (3) 普通索引 INDEX
	       这是最基本的索引，它没有任何限制。可以在创建表的时候指定，也可以修改表结构，如：
	       ALTER TABLE table_name ADD INDEX index_name (column
	   (4) 组合索引 INDEX
	       组合索引，即一个索引包含多个列。可以在创建表的时候指定，也可以修改表结构，如：
	       ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3)
	   (5) 全文索引 FULLTEXT
	       全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。
	       它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，
	       然后按照一定的算法规则智能地筛选出我们想要的搜索结果。
	       可以在创建表的时候指定，也可以修改表结构，如：
	       ALTER TABLE table_name ADD FULLTEXT (column)

**3. Varchar和char的区别**

	A: 1. char是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是： 
	   char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．
	  （在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，
	   每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）． 
	   2. char在存储的时候会截断尾部的空格，varchar和text不会。
	   3. 如果分配给char或varchar列的值超过列的最大长度,则对值进行裁剪

**4. UTF-8下面varchar能占多少字符？GBK呢？**

	A: GBK: varchar的上限32766 (65535/2)字节，text的上限相同
	   UTF-8: varchar = 21842 = (65535-1-2-4)/3
	   减1的原因是实际行的存储从第2个字节开始.
	   减2的原因是varchar头部的2个字节表示长度.
	   减4的原因是字段id的int类型占用4个字节.
	   除以3的原因是一个utf8字符占用3个字节.

**5. 使用过 NoSQL 吗？大概讲一下有什么不同**

	A: 用过Firebase
	   1.存储方式：
	   SQL数据存在特定结构的表中；而NoSQL则更加灵活和可扩展，存储方式可以省是JSON文档、哈希表或者其他方式。
	   2. 表/数据集合的数据的关系
	      在SQL中，必须定义好表和字段结构后才能添加数据，
	      例如定义表的主键(primary key)，索引(index),触发器(trigger),存储过程(stored procedure)等。
	      表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。
	      在NoSQL中，数据可以在任何时候任何地方添加，不需要先定义表。
	   3.SQL中的JOIN查询
	     SQL中可以使用JOIN表链接方式将多个关系数据表中的数据用一条简单的查询语句查询出来。
	     而NoSQL暂未提供类似JOIN的查询方式对多个数据集中的数据做查询。所以大部分NoSQL使用非规范化的数据存储方式存储数据。
	   4.数据耦合性
	     SQL中不允许删除已经被使用的外部数据，例如审核人表中的"熊三"已经被分配给了借阅人熊大，
	     那么在审核人表中将不允许删除熊三这条数据，以保证数据完整性。
	     而NoSQL中则没有这种强耦合的概念，可以随时删除任何数据。
	   5.事务
	     SQL中如果多张表数据需要同批次被更新，即如果其中一张表更新失败的话其他表也不能更新成功。
	     这种场景可以通过事务来控制，可以在所有命令完成后再统一提交事务。
	     而NoSQL中没有事务这个概念，每一个数据集的操作都是原子级的。

**7. 悲观锁vs乐观锁**

	A:  悲观锁: 指的是外界对数据修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 
		悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，
		否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。
		
		乐观锁 : 假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，
		才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 

**8. 数据库查询很慢怎么排查（慢查询日志加上explain）?**






